import path from 'path';
import fs from 'fs-extra';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';
import { Readable } from 'stream';
import type { GrablinConfig } from './config.js';
import { getAuthHeaders, hasToken, AuthError } from './auth.js';

const DEFAULT_API_URL = 'https://www.grabl.in';

// Security: Characters that are dangerous in paths
const UNSAFE_PATH_CHARS = /[<>:"|?*\x00-\x1f]/;
const PATH_TRAVERSAL_PATTERN = /\.\./;

/**
 * Security: Validate and normalize API URL
 * - Enforces HTTPS (rejects HTTP)
 * - Validates URL format
 * - Returns normalized URL without trailing slash
 */
function validateApiUrl(url: string): string {
  let parsed: URL;
  try {
    parsed = new URL(url);
  } catch (error) {
    throw new Error(`Invalid API URL: ${url}`);
  }

  // Security: Enforce HTTPS to prevent credential interception
  if (parsed.protocol !== 'https:') {
    // Allow localhost for development
    if (parsed.hostname !== 'localhost' && parsed.hostname !== '127.0.0.1') {
      throw new Error(
        `Security: API URL must use HTTPS. Got: ${url}\n` +
        `HTTP is only allowed for localhost development.`
      );
    }
  }

  // Return normalized URL without trailing slash
  return url.replace(/\/+$/, '');
}

export interface GenerateOptions {
  config: GrablinConfig;
  apiUrl?: string;
  output?: string;        // Extract to local directory
  pushToGithub?: boolean; // Push to GitHub repo
  repoName?: string;      // GitHub repo name (default: projectName)
  private?: boolean;      // Make repo private
  verbose?: boolean;
}

export interface GenerateResult {
  success: boolean;
  fileCount: number;
  error?: string;
  // For local output
  outputPath?: string;
  // For GitHub push
  repoUrl?: string;
  cloneCommand?: string;
}

/**
 * Generate project via Grablin API
 */
export async function generate(options: GenerateOptions): Promise<GenerateResult> {
  const { config, apiUrl: rawApiUrl = DEFAULT_API_URL, pushToGithub, output, verbose } = options;

  // Security: Validate and normalize API URL (enforces HTTPS)
  let apiUrl: string;
  try {
    apiUrl = validateApiUrl(rawApiUrl);
  } catch (error) {
    return {
      success: false,
      fileCount: 0,
      error: error instanceof Error ? error.message : 'Invalid API URL',
    };
  }

  // Token is always required
  if (!hasToken()) {
    return {
      success: false,
      fileCount: 0,
      error: 'GitHub token required. Set GITHUB_TOKEN or GH_TOKEN environment variable.',
    };
  }

  // Compute repo name for GitHub (if pushing)
  const repoName = options.repoName || config.projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');

  // Build API payload - must match backend /api/generate expectations
  const payload = {
    project: {
      name: config.projectName,
      description: config.description || `${config.projectName} - Generated by Grablin`,
      domain: config.domain,
      version: '1.0.0',
      // repo is used by backend for GitHub repo name (separate from project name)
      repo: pushToGithub ? repoName : undefined,
    },
    modules: config.modules.map(m => ({
      kind: m.kind,
      type: m.type,
      name: m.moduleId,
      layers: m.layers || [],
      enabled: true,
      fieldValues: m.fieldValues || {},
    })),
    environments: config.environments || ['dev', 'staging', 'prod'],
    productionEnv: 'prod',
    // Backend expects 'format' not 'output', and 'owner' at top level
    format: pushToGithub ? 'github' : 'zip',
    owner: pushToGithub ? config.owner : undefined,
  };

  if (verbose) {
    console.log('API URL:', apiUrl);
    console.log('Payload:', JSON.stringify(payload, null, 2));
  }

  try {
    const response = await fetch(`${apiUrl}/api/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...getAuthHeaders(),
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        fileCount: 0,
        error: `API error (${response.status}): ${errorText}`,
      };
    }

    // Handle different response types
    const contentType = response.headers.get('content-type');

    // GitHub push - returns JSON with repo info at top level
    if (pushToGithub || contentType?.includes('application/json')) {
      const result = await response.json() as {
        success: boolean;
        error?: string;
        message?: string;
        // GitHub push response - fields at top level
        repoUrl?: string;
        repository?: { url: string; html_url: string; clone_url: string };
        fileCount?: number;
        commit?: { sha: string };
        // Default JSON response - fields under data
        data?: {
          fileCount: number;
          files?: Record<string, unknown>;
        };
      };

      if (!result.success) {
        return {
          success: false,
          fileCount: 0,
          error: result.error || 'Unknown API error',
        };
      }

      // Handle GitHub push response (fields at top level)
      if (result.repoUrl || result.repository) {
        const repoUrl = result.repoUrl || result.repository?.html_url;
        return {
          success: true,
          fileCount: result.fileCount || 0,
          repoUrl,
          cloneCommand: result.repository?.clone_url ? `git clone ${result.repository.clone_url}` : undefined,
        };
      }

      // Handle default JSON response (fields under data)
      return {
        success: true,
        fileCount: result.data?.fileCount || Object.keys(result.data?.files || {}).length || 0,
      };
    }

    // Zip download - returns binary
    if (output) {
      const buffer = await response.arrayBuffer();
      const zipPath = path.join(output, `${config.projectName}.zip`);

      // Ensure output directory exists
      await fs.ensureDir(output);

      // Write zip file
      await fs.writeFile(zipPath, Buffer.from(buffer));

      // Extract zip
      const extractedPath = await extractZip(zipPath, output);

      // Remove zip file after extraction
      await fs.remove(zipPath);

      return {
        success: true,
        fileCount: 0, // TODO: count files after extraction
        outputPath: extractedPath,
      };
    }

    return {
      success: false,
      fileCount: 0,
      error: 'No output option specified (--output or --push-to-github)',
    };
  } catch (error) {
    return {
      success: false,
      fileCount: 0,
      error: (error as Error).message,
    };
  }
}

/**
 * Validate path is safe (no traversal, no unsafe characters)
 * @throws Error if path is unsafe
 */
function validatePath(filePath: string, context: string): void {
  if (PATH_TRAVERSAL_PATTERN.test(filePath)) {
    throw new Error(`${context}: Path traversal detected in "${filePath}"`);
  }
  if (UNSAFE_PATH_CHARS.test(filePath)) {
    throw new Error(`${context}: Unsafe characters in path "${filePath}"`);
  }
}

/**
 * Validate output directory is safe
 * @throws Error if directory is in a dangerous location
 */
function validateOutputDir(outputDir: string): void {
  const resolvedPath = path.resolve(outputDir);
  const cwd = process.cwd();

  // Must be under current working directory or explicitly /tmp
  const isUnderCwd = resolvedPath.startsWith(cwd + path.sep) || resolvedPath === cwd;
  const isUnderTmp = resolvedPath.startsWith('/tmp/') || resolvedPath.startsWith(path.join(require('os').tmpdir(), ''));

  if (!isUnderCwd && !isUnderTmp) {
    throw new Error(`Output directory must be under current directory or temp: ${outputDir}`);
  }

  // Prevent dangerous directories
  const dangerous = ['/etc', '/usr', '/bin', '/sbin', '/var', '/sys', '/proc', '/boot', '/dev', '/root'];
  for (const dir of dangerous) {
    if (resolvedPath.startsWith(dir + '/') || resolvedPath === dir) {
      throw new Error(`Cannot write to system directory: ${outputDir}`);
    }
  }
}

/**
 * Extract zip file to directory using pure JavaScript (no shell commands)
 *
 * SECURITY NOTE: This uses Node.js built-in zlib instead of shell commands
 * to prevent command injection vulnerabilities.
 */
async function extractZip(zipPath: string, outputDir: string): Promise<string> {
  // Validate paths before extraction
  validatePath(path.basename(zipPath), 'Zip file name');
  validateOutputDir(outputDir);

  const extractDir = path.join(outputDir, path.basename(zipPath, '.zip'));
  await fs.ensureDir(extractDir);

  // Use yauzl for safe zip extraction (commonly available)
  // Fall back to adm-zip if yauzl not available
  try {
    const AdmZip = (await import('adm-zip')).default;
    const zip = new AdmZip(zipPath);
    const entries = zip.getEntries();

    for (const entry of entries) {
      // Security: Validate each entry path
      const entryName = entry.entryName;

      // Skip entries with path traversal
      if (PATH_TRAVERSAL_PATTERN.test(entryName)) {
        console.warn(`Skipping unsafe entry: ${entryName}`);
        continue;
      }

      // Validate resolved path is within extractDir
      const targetPath = path.join(extractDir, entryName);
      const resolvedTarget = path.resolve(targetPath);
      const resolvedExtractDir = path.resolve(extractDir);

      if (!resolvedTarget.startsWith(resolvedExtractDir + path.sep) && resolvedTarget !== resolvedExtractDir) {
        console.warn(`Skipping entry outside target dir: ${entryName}`);
        continue;
      }

      if (entry.isDirectory) {
        await fs.ensureDir(targetPath);
      } else {
        await fs.ensureDir(path.dirname(targetPath));
        await fs.writeFile(targetPath, entry.getData());
      }
    }

    return extractDir;
  } catch (error: any) {
    // If adm-zip not available, throw helpful error
    if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {
      throw new Error(
        'Zip extraction requires adm-zip package. Install with: npm install adm-zip\n' +
        'Note: Shell-based extraction was removed for security reasons.'
      );
    }
    throw error;
  }
}

/**
 * List available modules from API
 */
export async function listModules(rawApiUrl: string = DEFAULT_API_URL): Promise<{
  success: boolean;
  modules?: Array<{
    id: string;
    type: string;
    name: string;
    description: string;
    kind: string;
    layers: string[];
  }>;
  error?: string;
}> {
  try {
    // Security: Validate and normalize API URL (enforces HTTPS)
    const apiUrl = validateApiUrl(rawApiUrl);
    const response = await fetch(`${apiUrl}/api/modules`);

    if (!response.ok) {
      return {
        success: false,
        error: `API error (${response.status})`,
      };
    }

    const result = await response.json() as {
      success: boolean;
      data?: {
        codeModules: any[];
        providerModules: any[];
        vcsModules: any[];
        extensions: any[];
        total: number;
      };
    };

    // Combine all module types into a single array
    const allModules = [
      ...(result.data?.codeModules || []),
      ...(result.data?.providerModules || []),
      ...(result.data?.vcsModules || []),
      ...(result.data?.extensions || []),
    ];

    return {
      success: true,
      modules: allModules,
    };
  } catch (error) {
    return {
      success: false,
      error: (error as Error).message,
    };
  }
}
