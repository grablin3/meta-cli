import path from 'path';
import fs from 'fs-extra';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';
import { Readable } from 'stream';
import { tmpdir } from 'os';
import { randomBytes } from 'crypto';
import type { GrablinConfig } from './config.js';
import { getAuthHeaders, hasToken, AuthError } from './auth.js';

const DEFAULT_API_URL = 'https://www.grabl.in';

// Security: Characters that are dangerous in paths
const UNSAFE_PATH_CHARS = /[<>:"|?*\x00-\x1f]/;
const PATH_TRAVERSAL_PATTERN = /\.\./;

/**
 * Security: Validate and normalize API URL
 * - Enforces HTTPS (rejects HTTP)
 * - Validates URL format
 * - Returns normalized URL without trailing slash
 */
function validateApiUrl(url: string): string {
  let parsed: URL;
  try {
    parsed = new URL(url);
  } catch (error) {
    throw new Error(`Invalid API URL: ${url}`);
  }

  // Security: Enforce HTTPS to prevent credential interception
  if (parsed.protocol !== 'https:') {
    // Allow localhost for development
    if (parsed.hostname !== 'localhost' && parsed.hostname !== '127.0.0.1') {
      throw new Error(
        `Security: API URL must use HTTPS. Got: ${url}\n` +
        `HTTP is only allowed for localhost development.`
      );
    }
  }

  // Return normalized URL without trailing slash
  return url.replace(/\/+$/, '');
}

export interface GenerateOptions {
  config: GrablinConfig;
  apiUrl?: string;
  output?: string;        // Extract to local directory
  pushToGithub?: boolean; // Push to GitHub repo
  repoName?: string;      // GitHub repo name (default: projectName)
  private?: boolean;      // Make repo private
  verbose?: boolean;
}

export interface GenerateResult {
  success: boolean;
  fileCount: number;
  error?: string;
  // For local output
  outputPath?: string;
  // For GitHub push
  repoUrl?: string;
  cloneCommand?: string;
}

/**
 * Generate project via Grablin API
 */
export async function generate(options: GenerateOptions): Promise<GenerateResult> {
  const { config, apiUrl: rawApiUrl = DEFAULT_API_URL, pushToGithub, output, verbose } = options;

  // Security: Validate and normalize API URL (enforces HTTPS)
  let apiUrl: string;
  try {
    apiUrl = validateApiUrl(rawApiUrl);
  } catch (error) {
    return {
      success: false,
      fileCount: 0,
      error: error instanceof Error ? error.message : 'Invalid API URL',
    };
  }

  // Token is always required
  if (!hasToken()) {
    return {
      success: false,
      fileCount: 0,
      error: 'GitHub token required. Set GITHUB_TOKEN or GH_TOKEN environment variable.',
    };
  }

  // H35: Compute repo name for GitHub with proper sanitization
  // GitHub repo names: max 100 chars, alphanumeric + hyphens, no leading/trailing hyphens
  let repoName = options.repoName || config.projectName
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')  // Replace invalid chars with hyphen
    .replace(/-+/g, '-')          // Collapse multiple hyphens
    .replace(/^-|-$/g, '')        // Remove leading/trailing hyphens
    .slice(0, 100);               // Enforce GitHub's 100 char limit

  // Ensure we have a valid name (fallback if result is empty)
  if (!repoName) {
    repoName = 'project';
  }

  // M36: Build API payload with sanitization - must match backend /api/generate expectations
  // Sanitize strings: trim, limit length, remove control characters
  const sanitizeString = (str: string, maxLen: number = 255): string => {
    return str
      .trim()
      .replace(/[\x00-\x1f\x7f-\x9f]/g, '') // Remove control chars
      .slice(0, maxLen);
  };

  const payload = {
    project: {
      name: sanitizeString(config.projectName, 100),
      description: sanitizeString(config.description || `${config.projectName} - Generated by Grablin`, 500),
      domain: sanitizeString(config.domain, 253), // RFC 1035 max domain length
      version: '1.0.0',
      // repo is used by backend for GitHub repo name (separate from project name)
      repo: pushToGithub ? sanitizeString(repoName, 100) : undefined,
    },
    modules: config.modules.map(m => ({
      kind: sanitizeString(m.kind, 20),
      type: sanitizeString(m.type, 50),
      name: sanitizeString(m.moduleId, 100),
      layers: Array.isArray(m.layers) ? m.layers.map(l => sanitizeString(String(l), 50)) : [],
      enabled: true,
      // M36: Sanitize fieldValues to prevent injection
      fieldValues: typeof m.fieldValues === 'object' && m.fieldValues !== null
        ? Object.fromEntries(
            Object.entries(m.fieldValues).map(([k, v]) => [
              sanitizeString(k, 100),
              typeof v === 'string' ? sanitizeString(v, 1000) : v
            ])
          )
        : {},
    })),
    environments: Array.isArray(config.environments)
      ? config.environments.map(e => sanitizeString(String(e), 50))
      : ['dev', 'staging', 'prod'],
    productionEnv: 'prod',
    // Backend expects 'format' not 'output', and 'owner' at top level
    format: pushToGithub ? 'github' : 'zip',
    owner: pushToGithub ? sanitizeString(config.owner, 254) : undefined, // RFC 5321 max email length
  };

  // M43: Sanitize verbose output to prevent data leakage
  if (verbose) {
    console.log('API URL:', apiUrl);
    // Sanitize payload: mask sensitive field values, show structure only
    const sanitizedPayload = {
      ...payload,
      modules: payload.modules.map(m => ({
        ...m,
        fieldValues: m.fieldValues && Object.keys(m.fieldValues).length > 0
          ? { _sanitized: `${Object.keys(m.fieldValues).length} fields` }
          : {},
      })),
    };
    console.log('Payload:', JSON.stringify(sanitizedPayload, null, 2));
  }

  try {
    // H33: Add request timeout (5 minutes for generation, which can be slow)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5 * 60 * 1000);

    let response: Response;
    try {
      response = await fetch(`${apiUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...getAuthHeaders(),
        },
        body: JSON.stringify(payload),
        signal: controller.signal,
      });
    } finally {
      clearTimeout(timeoutId);
    }

    if (!response.ok) {
      const errorText = await response.text();
      // H32: Sanitize error response to avoid leaking internal details
      // Only show first 200 chars of error, strip potential stack traces
      let sanitizedError = errorText
        .replace(/at\s+[\w.<>]+\s+\([^)]+\)/g, '')  // Remove stack trace lines
        .replace(/\n\s*\n/g, '\n')                   // Remove empty lines
        .trim()
        .slice(0, 200);
      if (errorText.length > 200) {
        sanitizedError += '...';
      }
      return {
        success: false,
        fileCount: 0,
        error: `API error (${response.status}): ${sanitizedError}`,
      };
    }

    // Handle different response types
    const contentType = response.headers.get('content-type');

    // GitHub push - returns JSON with repo info at top level
    if (pushToGithub || contentType?.includes('application/json')) {
      // M41: Validate API response structure before using
      let result: any;
      try {
        result = await response.json();
      } catch (error) {
        return {
          success: false,
          fileCount: 0,
          error: 'Invalid JSON response from API',
        };
      }

      // M41: Validate response has expected structure
      if (typeof result !== 'object' || result === null) {
        return {
          success: false,
          fileCount: 0,
          error: 'API response is not a valid object',
        };
      }

      if (typeof result.success !== 'boolean') {
        return {
          success: false,
          fileCount: 0,
          error: 'API response missing required "success" field',
        };
      }

      if (!result.success) {
        return {
          success: false,
          fileCount: 0,
          error: typeof result.error === 'string' ? result.error : 'Unknown API error',
        };
      }

      // Handle GitHub push response (fields at top level)
      if (result.repoUrl || result.repository) {
        // M41: Validate GitHub-specific fields
        const repoUrl = typeof result.repoUrl === 'string' ? result.repoUrl :
                        (result.repository && typeof result.repository.html_url === 'string' ? result.repository.html_url : undefined);
        const cloneUrl = result.repository && typeof result.repository.clone_url === 'string' ? result.repository.clone_url : undefined;

        return {
          success: true,
          fileCount: typeof result.fileCount === 'number' ? result.fileCount : 0,
          repoUrl,
          cloneCommand: cloneUrl ? `git clone ${cloneUrl}` : undefined,
        };
      }

      // Handle default JSON response (fields under data)
      // M41: Validate data field structure
      const fileCount = result.data && typeof result.data.fileCount === 'number'
        ? result.data.fileCount
        : (result.data && result.data.files && typeof result.data.files === 'object'
          ? Object.keys(result.data.files).length
          : 0);

      return {
        success: true,
        fileCount,
      };
    }

    // Zip download - returns binary
    if (output) {
      // M39: Validate response size before consuming
      const contentLength = response.headers.get('content-length');
      const MAX_ZIP_SIZE = 100 * 1024 * 1024; // 100MB max
      if (contentLength && parseInt(contentLength, 10) > MAX_ZIP_SIZE) {
        return {
          success: false,
          fileCount: 0,
          error: `Response too large: ${Math.round(parseInt(contentLength, 10) / 1024 / 1024)}MB (max ${MAX_ZIP_SIZE / 1024 / 1024}MB)`,
        };
      }

      const buffer = await response.arrayBuffer();

      // M39: Double-check actual size
      if (buffer.byteLength > MAX_ZIP_SIZE) {
        return {
          success: false,
          fileCount: 0,
          error: `Downloaded file too large: ${Math.round(buffer.byteLength / 1024 / 1024)}MB (max ${MAX_ZIP_SIZE / 1024 / 1024}MB)`,
        };
      }

      // M42: Use secure temporary directory for zip file with proper permissions
      const secureTempDir = await createSecureTempDir('grablin-zip-');
      const zipPath = path.join(secureTempDir, `${config.projectName}.zip`);

      try {
        // Write zip file to secure temp directory
        await fs.writeFile(zipPath, Buffer.from(buffer), { mode: 0o600 });

        // Ensure output directory exists
        await fs.ensureDir(output);

        // Extract zip to final output location
        const extractedPath = await extractZip(zipPath, output);

        // Clean up secure temp directory
        await fs.remove(secureTempDir);

        return {
          success: true,
          fileCount: 0, // TODO: count files after extraction
          outputPath: extractedPath,
        };
      } catch (error) {
        // Clean up secure temp directory on error
        await fs.remove(secureTempDir).catch(() => {});
        throw error;
      }
    }

    return {
      success: false,
      fileCount: 0,
      error: 'No output option specified (--output or --push-to-github)',
    };
  } catch (error) {
    // H33: Handle timeout/abort errors
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        fileCount: 0,
        error: 'Request timeout - API took too long to respond',
      };
    }
    return {
      success: false,
      fileCount: 0,
      error: (error as Error).message,
    };
  }
}

/**
 * M42: Create secure temporary directory with proper permissions
 * Returns a unique temporary directory path with mode 0700 (owner-only access)
 */
async function createSecureTempDir(prefix: string = 'grablin-'): Promise<string> {
  const tmpBase = tmpdir();
  const uniqueId = randomBytes(16).toString('hex');
  const tempDir = path.join(tmpBase, `${prefix}${uniqueId}`);

  // Create directory with restricted permissions (0700 = owner-only)
  await fs.mkdir(tempDir, { mode: 0o700, recursive: true });

  return tempDir;
}

/**
 * Validate path is safe (no traversal, no unsafe characters)
 * @throws Error if path is unsafe
 */
function validatePath(filePath: string, context: string): void {
  if (PATH_TRAVERSAL_PATTERN.test(filePath)) {
    throw new Error(`${context}: Path traversal detected in "${filePath}"`);
  }
  if (UNSAFE_PATH_CHARS.test(filePath)) {
    throw new Error(`${context}: Unsafe characters in path "${filePath}"`);
  }
}

/**
 * Validate output directory is safe
 * @throws Error if directory is in a dangerous location
 */
function validateOutputDir(outputDir: string): void {
  const resolvedPath = path.resolve(outputDir);
  const cwd = process.cwd();

  // Must be under current working directory or explicitly /tmp
  const isUnderCwd = resolvedPath.startsWith(cwd + path.sep) || resolvedPath === cwd;
  const isUnderTmp = resolvedPath.startsWith('/tmp/') || resolvedPath.startsWith(path.join(require('os').tmpdir(), ''));

  if (!isUnderCwd && !isUnderTmp) {
    throw new Error(`Output directory must be under current directory or temp: ${outputDir}`);
  }

  // Prevent dangerous directories
  const dangerous = ['/etc', '/usr', '/bin', '/sbin', '/var', '/sys', '/proc', '/boot', '/dev', '/root'];
  for (const dir of dangerous) {
    if (resolvedPath.startsWith(dir + '/') || resolvedPath === dir) {
      throw new Error(`Cannot write to system directory: ${outputDir}`);
    }
  }
}

/**
 * Extract zip file to directory using pure JavaScript (no shell commands)
 *
 * SECURITY NOTE: This uses Node.js built-in zlib instead of shell commands
 * to prevent command injection vulnerabilities.
 */
async function extractZip(zipPath: string, outputDir: string): Promise<string> {
  // Validate paths before extraction
  validatePath(path.basename(zipPath), 'Zip file name');
  validateOutputDir(outputDir);

  const extractDir = path.join(outputDir, path.basename(zipPath, '.zip'));
  await fs.ensureDir(extractDir);

  // Use yauzl for safe zip extraction (commonly available)
  // Fall back to adm-zip if yauzl not available
  try {
    const AdmZip = (await import('adm-zip')).default;
    const zip = new AdmZip(zipPath);
    const entries = zip.getEntries();

    for (const entry of entries) {
      // Security: Validate each entry path
      const entryName = entry.entryName;

      // Skip entries with path traversal
      if (PATH_TRAVERSAL_PATTERN.test(entryName)) {
        console.warn(`Skipping unsafe entry: ${entryName}`);
        continue;
      }

      // Validate resolved path is within extractDir
      const targetPath = path.join(extractDir, entryName);
      const resolvedTarget = path.resolve(targetPath);
      const resolvedExtractDir = path.resolve(extractDir);

      if (!resolvedTarget.startsWith(resolvedExtractDir + path.sep) && resolvedTarget !== resolvedExtractDir) {
        console.warn(`Skipping entry outside target dir: ${entryName}`);
        continue;
      }

      if (entry.isDirectory) {
        await fs.ensureDir(targetPath);
      } else {
        await fs.ensureDir(path.dirname(targetPath));
        await fs.writeFile(targetPath, entry.getData());
      }
    }

    return extractDir;
  } catch (error: any) {
    // If adm-zip not available, throw helpful error
    if (error.code === 'MODULE_NOT_FOUND' || error.code === 'ERR_MODULE_NOT_FOUND') {
      throw new Error(
        'Zip extraction requires adm-zip package. Install with: npm install adm-zip\n' +
        'Note: Shell-based extraction was removed for security reasons.'
      );
    }
    throw error;
  }
}

/**
 * List available modules from API
 */
export async function listModules(rawApiUrl: string = DEFAULT_API_URL): Promise<{
  success: boolean;
  modules?: Array<{
    id: string;
    type: string;
    name: string;
    description: string;
    kind: string;
    layers: string[];
  }>;
  error?: string;
}> {
  try {
    // Security: Validate and normalize API URL (enforces HTTPS)
    const apiUrl = validateApiUrl(rawApiUrl);

    // H33: Add request timeout (30 seconds for module listing)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30 * 1000);

    let response: Response;
    try {
      response = await fetch(`${apiUrl}/api/modules`, {
        signal: controller.signal,
      });
    } finally {
      clearTimeout(timeoutId);
    }

    if (!response.ok) {
      return {
        success: false,
        error: `API error (${response.status})`,
      };
    }

    const result = await response.json() as {
      success: boolean;
      data?: {
        codeModules: any[];
        providerModules: any[];
        vcsModules: any[];
        extensions: any[];
        total: number;
      };
    };

    // Combine all module types into a single array
    const allModules = [
      ...(result.data?.codeModules || []),
      ...(result.data?.providerModules || []),
      ...(result.data?.vcsModules || []),
      ...(result.data?.extensions || []),
    ];

    return {
      success: true,
      modules: allModules,
    };
  } catch (error) {
    // H33: Handle timeout/abort errors
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        error: 'Request timeout - API took too long to respond',
      };
    }
    return {
      success: false,
      error: (error as Error).message,
    };
  }
}
