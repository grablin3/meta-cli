import path from 'path';
import fs from 'fs-extra';
import type { GrablinConfig } from './config.js';
import { getAuthHeaders, hasToken, AuthError } from './auth.js';

const DEFAULT_API_URL = 'https://api.grablin.com';

export interface GenerateOptions {
  config: GrablinConfig;
  apiUrl?: string;
  output?: string;        // Extract to local directory
  pushToGithub?: boolean; // Push to GitHub repo
  repoName?: string;      // GitHub repo name (default: projectName)
  private?: boolean;      // Make repo private
  verbose?: boolean;
}

export interface GenerateResult {
  success: boolean;
  fileCount: number;
  error?: string;
  // For local output
  outputPath?: string;
  // For GitHub push
  repoUrl?: string;
  cloneCommand?: string;
}

/**
 * Generate project via Grablin API
 */
export async function generate(options: GenerateOptions): Promise<GenerateResult> {
  const { config, apiUrl = DEFAULT_API_URL, pushToGithub, output, verbose } = options;

  // Token is always required
  if (!hasToken()) {
    return {
      success: false,
      fileCount: 0,
      error: 'GitHub token required. Set GITHUB_TOKEN or GH_TOKEN environment variable.',
    };
  }

  // Build API payload
  const payload = {
    project: {
      name: config.projectName,
      description: config.description || `${config.projectName} - Generated by Grablin`,
      domain: config.domain,
      owner: config.owner,
      version: '1.0.0',
    },
    modules: config.modules.map(m => ({
      kind: m.kind,
      type: m.type,
      name: m.moduleId,
      layers: m.layers || [],
      enabled: true,
      fieldValues: m.fieldValues || {},
    })),
    environments: config.environments || ['dev', 'staging', 'prod'],
    productionEnv: 'prod',
    // Output options
    output: pushToGithub ? 'github' : 'zip',
    github: pushToGithub ? {
      repo: options.repoName || config.projectName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
      private: options.private ?? false,
    } : undefined,
  };

  if (verbose) {
    console.log('API URL:', apiUrl);
    console.log('Payload:', JSON.stringify(payload, null, 2));
  }

  try {
    const response = await fetch(`${apiUrl}/api/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...getAuthHeaders(),
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        fileCount: 0,
        error: `API error (${response.status}): ${errorText}`,
      };
    }

    // Handle different response types
    const contentType = response.headers.get('content-type');

    // GitHub push - returns JSON with repo info
    if (pushToGithub || contentType?.includes('application/json')) {
      const result = await response.json() as {
        success: boolean;
        error?: string;
        data?: {
          fileCount: number;
          repoUrl?: string;
          cloneCommand?: string;
        };
      };

      if (!result.success) {
        return {
          success: false,
          fileCount: 0,
          error: result.error || 'Unknown API error',
        };
      }

      return {
        success: true,
        fileCount: result.data?.fileCount || 0,
        repoUrl: result.data?.repoUrl,
        cloneCommand: result.data?.cloneCommand,
      };
    }

    // Zip download - returns binary
    if (output) {
      const buffer = await response.arrayBuffer();
      const zipPath = path.join(output, `${config.projectName}.zip`);

      // Ensure output directory exists
      await fs.ensureDir(output);

      // Write zip file
      await fs.writeFile(zipPath, Buffer.from(buffer));

      // Extract zip
      const extractedPath = await extractZip(zipPath, output);

      // Remove zip file after extraction
      await fs.remove(zipPath);

      return {
        success: true,
        fileCount: 0, // TODO: count files after extraction
        outputPath: extractedPath,
      };
    }

    return {
      success: false,
      fileCount: 0,
      error: 'No output option specified (--output or --push-to-github)',
    };
  } catch (error) {
    return {
      success: false,
      fileCount: 0,
      error: (error as Error).message,
    };
  }
}

/**
 * Extract zip file to directory
 */
async function extractZip(zipPath: string, outputDir: string): Promise<string> {
  // Use native unzip command for simplicity
  const { execSync } = await import('child_process');
  const extractDir = path.join(outputDir, path.basename(zipPath, '.zip'));

  await fs.ensureDir(extractDir);
  execSync(`unzip -o "${zipPath}" -d "${extractDir}"`, { stdio: 'pipe' });

  return extractDir;
}

/**
 * List available modules from API
 */
export async function listModules(apiUrl: string = DEFAULT_API_URL): Promise<{
  success: boolean;
  modules?: Array<{
    id: string;
    type: string;
    name: string;
    description: string;
    kind: string;
    layers: string[];
  }>;
  error?: string;
}> {
  try {
    const response = await fetch(`${apiUrl}/api/modules`);

    if (!response.ok) {
      return {
        success: false,
        error: `API error (${response.status})`,
      };
    }

    const result = await response.json() as {
      success: boolean;
      data?: { modules: any[] };
    };

    return {
      success: true,
      modules: result.data?.modules || [],
    };
  } catch (error) {
    return {
      success: false,
      error: (error as Error).message,
    };
  }
}
